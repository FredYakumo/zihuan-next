import { HorizontalBox, VerticalBox, ScrollView } from "std-widgets.slint";

export struct PortVm {
    name: string,
    is_input: bool,
}

export struct NodeVm {
    id: string,
    label: string,
    x: float,
    y: float,
    input_ports: [PortVm],
    output_ports: [PortVm],
}

export struct EdgeVm {
    from_node_id: string,
    from_port: string,
    to_node_id: string,
    to_port: string,
    from_x: float,
    from_y: float,
    to_x: float,
    to_y: float,
}

export struct EdgeSegmentVm {
    x: float,
    y: float,
    width: float,
    height: float,
}

export struct EdgeCornerVm {
    x: float,
    y: float,
}

export struct EdgeLabelVm {
    text: string,
    x: float,
    y: float,
    width: float,
    height: float,
}

export struct GridLineVm {
    x1: float,
    y1: float,
    x2: float,
    y2: float,
}

export struct NodeTypeVm {
    type_id: string,
    display_name: string,
    category: string,
    description: string,
}

component CjkText inherits Text {
    font-family: "Heiti SC";
}

component CjkButton inherits Rectangle {
    in property <string> text;
    callback clicked();

    width: 120px;
    height: 32px;
    background: #2f2f2f;
    border-radius: 6px;
    border-width: 1px;
    border-color: #4a4a4a;

    TouchArea {
        clicked => { root.clicked(); }
    }

    CjkText {
        text: root.text;
        color: #f0f0f0;
        vertical-alignment: center;
        horizontal-alignment: center;
        font-size: 12px;
    }
}

component NodeItem inherits Rectangle {
    in property <string> node_id;
    in property <string> label;
    in property <float> x_pos;
    in property <float> y_pos;
    in property <[PortVm]> input_ports;
    in property <[PortVm]> output_ports;
    in property <float> grid_size;
    in property <float> node_width_cells;
    in property <float> header_rows;
    in property <float> min_rows;
    
    callback node_moved(float, float);
    callback node_move_finished(float, float);
    callback port_clicked(string, string, bool);

    property <float> offset-x: 0;
    property <float> offset-y: 0;
    property <float> drag-start-x: 0;
    property <float> drag-start-y: 0;
    property <bool> is-dragging: false;

    x: (x_pos + offset-x) * 1px;
    y: (y_pos + offset-y) * 1px;
    width: (grid_size * node_width_cells) * 1px;
    height: (grid_size * max(min_rows, header_rows + max(input_ports.length, output_ports.length))) * 1px;
    background: touch.pressed ? #3a3a3a : #2b2b2b;
    border-radius: 8px;
    border-width: 1px;
    border-color: #4a4a4a;

    touch := TouchArea {
        pointer-event(event) => {
            if (event.kind == PointerEventKind.down) {
                is-dragging = true;
                drag-start-x = self.mouse-x / 1px;
                drag-start-y = self.mouse-y / 1px;
            } else if (event.kind == PointerEventKind.up) {
                is-dragging = false;
                offset-x = (self.mouse-x / 1px - drag-start-x);
                offset-y = (self.mouse-y / 1px - drag-start-y);
                root.node_moved(root.x_pos + offset-x, root.y_pos + offset-y);
                root.node_move_finished(root.x_pos + offset-x, root.y_pos + offset-y);
            }
        }
        
        moved => {
            if (self.pressed && is-dragging) {
                // Calculate offset and move node directly to follow mouse
                offset-x = (self.mouse-x / 1px - drag-start-x);
                offset-y = (self.mouse-y / 1px - drag-start-y);
                root.node_moved(root.x_pos + offset-x, root.y_pos + offset-y);
            }
        }
    }

    CjkText {
        text: root.label;
        color: #f0f0f0;
        horizontal-alignment: center;
        font-size: 14px;
        font-weight: 700;
        height: (grid_size * header_rows) * 1px;
        width: parent.width;
        x: 0px;
        y: 0px;
    }

    for port[i] in input_ports: Rectangle {
        x: (grid_size * 0.2) * 1px;
        y: (grid_size * header_rows + i * grid_size + grid_size * 0.2) * 1px;
        width: (grid_size * 0.6) * 1px;
        height: (grid_size * 0.6) * 1px;
        border-radius: (grid_size * 0.3) * 1px;
        background: #7a5a1f;
        border-width: 1px;
        border-color: #b58a3b;

        TouchArea {
            pointer-event(event) => {
                if (event.kind == PointerEventKind.down) {
                    root.port_clicked(root.node_id, port.name, true);
                }
            }
        }
    }

    for port[i] in input_ports: CjkText {
        text: port.name;
        color: #cccccc;
        font-size: 10px;
        vertical-alignment: center;
        x: (grid_size) * 1px;
        y: (grid_size * header_rows + i * grid_size) * 1px;
        width: (grid_size * (node_width_cells - 2)) * 1px;
        height: (grid_size) * 1px;
    }

    for port[i] in output_ports: Rectangle {
        x: (grid_size * (node_width_cells - 1) + grid_size * 0.2) * 1px;
        y: (grid_size * header_rows + i * grid_size + grid_size * 0.2) * 1px;
        width: (grid_size * 0.6) * 1px;
        height: (grid_size * 0.6) * 1px;
        border-radius: (grid_size * 0.3) * 1px;
        background: #7a5a1f;
        border-width: 1px;
        border-color: #b58a3b;

        TouchArea {
            pointer-event(event) => {
                if (event.kind == PointerEventKind.down) {
                    root.port_clicked(root.node_id, port.name, false);
                }
            }
        }
    }

    for port[i] in output_ports: CjkText {
        text: port.name;
        color: #cccccc;
        font-size: 10px;
        vertical-alignment: center;
        horizontal-alignment: right;
        x: (grid_size) * 1px;
        y: (grid_size * header_rows + i * grid_size) * 1px;
        width: (grid_size * (node_width_cells - 2)) * 1px;
        height: (grid_size) * 1px;
    }
}

component GraphCanvas inherits Rectangle {
    in property <[NodeVm]> nodes;
    in property <[EdgeVm]> edges;
    in property <[EdgeSegmentVm]> edge_segments;
    in property <[EdgeCornerVm]> edge_corners;
    in property <[EdgeLabelVm]> edge_labels;
    in property <[GridLineVm]> grid_lines;
    in property <float> grid_size;
    in property <float> edge_thickness;
    in property <bool> drag_line_visible;
    in property <float> drag_line_from_x;
    in property <float> drag_line_from_y;
    in property <float> drag_line_to_x;
    in property <float> drag_line_to_y;
    
    callback node_moved(string, float, float);
    callback node_move_finished(string, float, float);
    callback port_clicked(string, string, bool);
    callback pointer_moved(float, float);
    callback cancel_connect();

    in-out property <bool> dragging: false;
    in-out property <string> drag_from_node_id: "";
    in-out property <string> drag_from_port: "";
    in-out property <bool> drag_from_is_input: false;

    background: #1e1e1e;

    for line in grid_lines: Path {
        width: parent.width;
        height: parent.height;
        x: 0px;
        y: 0px;
        fill: transparent;
        stroke: #2a2a2a;
        stroke-width: 1px;
        clip: false;
        viewbox-x: 0;
        viewbox-y: 0;
        viewbox-width: parent.width / 1px;
        viewbox-height: parent.height / 1px;

        MoveTo {
            x: line.x1;
            y: line.y1;
        }

        LineTo {
            x: line.x2;
            y: line.y2;
        }
    }

    drag_area := TouchArea {
        pointer-event(event) => {
            if (event.kind == PointerEventKind.down && event.button == PointerEventButton.right) {
                root.cancel_connect();
            }
        }

        moved => {
            root.pointer_moved(self.mouse-x / 1px, self.mouse-y / 1px);
        }
    }

    for segment in edge_segments: Rectangle {
        x: segment.x * 1px;
        y: segment.y * 1px;
        width: segment.width * 1px;
        height: segment.height * 1px;
        background: #ffffff;
        border-radius: (root.edge_thickness / 2) * 1px;
    }

    for corner in edge_corners: Rectangle {
        x: (corner.x - root.edge_thickness / 2) * 1px;
        y: (corner.y - root.edge_thickness / 2) * 1px;
        width: root.edge_thickness * 1px;
        height: root.edge_thickness * 1px;
        background: #ffffff;
        border-radius: (root.edge_thickness / 2) * 1px;
    }

    for label in edge_labels: Rectangle {
        x: (label.x - label.width / 2) * 1px;
        y: (label.y - label.height / 2) * 1px;
        width: label.width * 1px;
        height: label.height * 1px;
        background: #1e1e1ecc;
        border-radius: 4px;
        border-width: 1px;
        border-color: #444444;

        CjkText {
            text: label.text;
            color: #ffffff;
            horizontal-alignment: center;
            vertical-alignment: center;
            font-size: 10px;
        }
    }

    if root.drag_line_visible: Path {
        width: parent.width;
        height: parent.height;
        x: 0px;
        y: 0px;
        fill: transparent;
        stroke: #ffffff;
        stroke-width: root.edge_thickness * 1px;
        viewbox-x: 0;
        viewbox-y: 0;
        viewbox-width: parent.width / 1px;
        viewbox-height: parent.height / 1px;

        MoveTo {
            x: root.drag_line_from_x;
            y: root.drag_line_from_y;
        }

        LineTo {
            x: (root.drag_line_from_x + root.drag_line_to_x) / 2;
            y: root.drag_line_from_y;
        }

        LineTo {
            x: (root.drag_line_from_x + root.drag_line_to_x) / 2;
            y: root.drag_line_to_y;
        }

        LineTo {
            x: root.drag_line_to_x;
            y: root.drag_line_to_y;
        }
    }

    for node in nodes: NodeItem {
        node_id: node.id;
        label: node.label;
        x_pos: node.x;
        y_pos: node.y;
        input_ports: node.input_ports;
        output_ports: node.output_ports;
        grid_size: root.grid_size;
        node_width_cells: 6;
        header_rows: 2;
        min_rows: 3;
        
        node_moved(x, y) => {
            root.node_moved(node.id, x, y);
        }

        node_move_finished(x, y) => {
            root.node_move_finished(node.id, x, y);
        }
        
        port_clicked(node_id, port_name, is_input) => {
            root.port_clicked(node_id, port_name, is_input);
        }
    }
}

export component NodeGraphWindow inherits Window {
    in property <[NodeVm]> nodes;
    in property <[EdgeVm]> edges;
    in property <[EdgeSegmentVm]> edge_segments;
    in property <[EdgeCornerVm]> edge_corners;
    in property <[EdgeLabelVm]> edge_labels;
    in property <[GridLineVm]> grid_lines;
    in property <float> grid_size: 20;
    in property <float> edge_thickness: 6;
    in property <string> connection_status: "";
    in property <string> current_file;
    in property <bool> show_node_selector: false;
    in property <[NodeTypeVm]> available_node_types;
    in property <bool> drag_line_visible: false;
    in property <float> drag_line_from_x: 0;
    in property <float> drag_line_from_y: 0;
    in property <float> drag_line_to_x: 0;
    in property <float> drag_line_to_y: 0;
    in-out property <bool> dragging: false;
    in-out property <string> drag_from_node_id: "";
    in-out property <string> drag_from_port: "";
    in-out property <bool> drag_from_is_input: false;

    callback open_json();
    callback add_node(string);
    callback show_node_type_menu();
    callback hide_node_type_menu();
    callback node_moved(string, float, float);
    callback node_move_finished(string, float, float);
    callback port_clicked(string, string, bool);
    callback pointer_moved(float, float);
    callback cancel_connect();

    title: "Zihuan Node Graph Viewer";
    width: 1200px;
    height: 800px;

    HorizontalBox {
        spacing: 12px;
        padding: 12px;

        GraphCanvas {
            width: 860px;
            height: 760px;
            nodes: root.nodes;
            edges: root.edges;
            edge_segments: root.edge_segments;
            edge_corners: root.edge_corners;
            edge_labels: root.edge_labels;
            grid_lines: root.grid_lines;
            grid_size: root.grid_size;
            edge_thickness: root.edge_thickness;
            drag_line_visible: root.drag_line_visible;
            drag_line_from_x: root.drag_line_from_x;
            drag_line_from_y: root.drag_line_from_y;
            drag_line_to_x: root.drag_line_to_x;
            drag_line_to_y: root.drag_line_to_y;
            dragging: root.dragging;
            drag_from_node_id: root.drag_from_node_id;
            drag_from_port: root.drag_from_port;
            drag_from_is_input: root.drag_from_is_input;
            
            node_moved(node_id, x, y) => {
                root.node_moved(node_id, x, y);
            }

            node_move_finished(node_id, x, y) => {
                root.node_move_finished(node_id, x, y);
            }
            
            port_clicked(node_id, port_name, is_input) => {
                root.port_clicked(node_id, port_name, is_input);
            }
            pointer_moved(x, y) => {
                root.pointer_moved(x, y);
            }
            cancel_connect() => {
                root.cancel_connect();
            }
        }

        VerticalBox {
            width: 300px;
            height: 760px;
            spacing: 8px;

            CjkButton {
                text: "读取节点图文件";
                clicked => { root.open_json(); }
            }

            CjkButton {
                text: "新增节点";
                clicked => { root.show_node_type_menu(); }
            }

            CjkText {
                text: root.current_file;
                font-size: 12px;
                color: #555555;
                wrap: word-wrap;
            }

            CjkText {
                text: root.connection_status;
                font-size: 12px;
                color: #8ab4f8;
                wrap: word-wrap;
            }

            CjkText {
                text: "Edges";
                font-size: 16px;
                color: #f0f0f0;
            }

            Rectangle {
                background: #2b2b2b;
                border-radius: 4px;
                height: 200px;
                
                ScrollView {
                    VerticalBox {
                        padding: 4px;
                        spacing: 2px;
                        
                        for edge in edges: CjkText {
                            text: edge.from_node_id + ":" + edge.from_port + " → " + edge.to_node_id + ":" + edge.to_port;
                            font-size: 10px;
                            color: #aaaaaa;
                        }
                    }
                }
            }
        }
    }

    if root.show_node_selector: Rectangle {
        width: 100%;
        height: 100%;
        background: #00000080;

        TouchArea {
            clicked => { root.hide_node_type_menu(); }
        }

        Rectangle {
            x: (parent.width - self.width) / 2;
            y: (parent.height - self.height) / 2;
            width: 600px;
            height: 500px;
            background: #2b2b2b;
            border-radius: 12px;
            border-width: 2px;
            border-color: #4a4a4a;

            TouchArea {}

            VerticalBox {
                padding: 16px;
                spacing: 12px;

                CjkText {
                    text: "选择节点类型";
                    font-size: 18px;
                    color: #f0f0f0;
                    horizontal-alignment: center;
                    height: 30px;
                }

                Rectangle {
                    background: #1e1e1e;
                    border-radius: 6px;
                    border-color: #333333;
                    border-width: 1px;
                    
                    ScrollView {
                        viewport-width: parent.width;
                        viewport-height: root.available_node_types.length * 85px; 

                        VerticalBox {
                            padding: 8px;
                            spacing: 8px;
                            alignment: start;

                            for node_type in root.available_node_types: Rectangle {
                                height: 80px;
                                background: #2f2f2f;
                                border-radius: 6px;
                                border-width: 1px;
                                border-color: #4a4a4a;

                                TouchArea {
                                    clicked => { 
                                        root.add_node(node_type.type_id);
                                        root.hide_node_type_menu();
                                    }
                                }

                                VerticalLayout {
                                    padding: 10px;
                                    spacing: 6px;

                                    HorizontalLayout {
                                        spacing: 8px;
                                        CjkText {
                                            text: node_type.display_name;
                                            font-size: 16px;
                                            color: #ffffff;
                                            font-weight: 700;
                                            vertical-alignment: center;
                                        }

                                        Rectangle {
                                            background: #3a3a3a;
                                            border-radius: 4px;
                                            width: self.height * 2.5; 
                                            
                                            HorizontalLayout {
                                                padding-left: 6px;
                                                padding-right: 6px;
                                                CjkText {
                                                    text: node_type.category;
                                                    font-size: 11px;
                                                    color: #aaaaaa;
                                                    vertical-alignment: center;
                                                    horizontal-alignment: center;
                                                }
                                            }
                                        }
                                    }

                                    CjkText {
                                        text: node_type.description;
                                        font-size: 13px;
                                        color: #bbbbbb;
                                        wrap: word-wrap;
                                        vertical-alignment: top;
                                        overflow: elide;
                                    }
                                }
                            }
                        }
                    }
                }

                HorizontalBox {
                    alignment: center;
                    CjkButton {
                        text: "取消";
                        clicked => { root.hide_node_type_menu(); }
                    }
                }
            }
        }
    }
}
